final_rec <-
wine.recipe %>%
finalize_recipe(optim.params) %>%
prep()
model.tuned <-
wine.dt %>%
finalize_model(optim.params) %>%
fit(classdigit ~ ., data = wine.train)
wine.dt.model %>%
predict(wine.test) %>%
bind_cols(wine.test) %>%
metrics(truth = classdigit, estimate = .pred_class)
wine.dt.model %>%
predict(wine.test) %>%
bind_cols(wine.test) %>%
metrics(truth = classdigit, estimate = .pred_class)
rpart.plot(wine.dt.model$fit, roundint=FALSE)
wine.lr = logistic_reg(mode = "classification",
penalty = tune()) %>%
set_engine("glm")
folds <- vfold_cv(wine.train, repeats = 2)
tree.wflow =
workflow() %>%
add_model(wine.dt) %>%
add_recipe(wine.recipe)
tree.set <- parameters(tree.wflow)
tree.wflow =
workflow() %>%
add_model(wine.lr) %>%
add_recipe(wine.recipe)
tree.set <- parameters(tree.wflow)
search_res =
tune_bayes(
tree.wflow,
resamples = folds,
param_info = tree.set,
initial = 5,
iter = 30,
metrics = metric_set(accuracy),
control = control_bayes(no_improve = 20, verbose = TRUE)
)
lr.wflow
tree.set <- parameters(lr.wflow)
lr.set
search_res =
tune_bayes(
tree.wflow,
resamples = folds,
param_info = lr.set,
initial = 5,
iter = 30,
metrics = metric_set(accuracy),
control = control_bayes(no_improve = 20, verbose = TRUE)
)
lr.set
lr.set <- parameters(lr.wflow)
lr.wflow =
workflow() %>%
add_model(wine.lr) %>%
add_recipe(wine.recipe)
lr.set <- parameters(lr.wflow)
search_res =
tune_bayes(
tree.wflow,
resamples = folds,
param_info = lr.set,
initial = 5,
iter = 30,
metrics = metric_set(accuracy),
control = control_bayes(no_improve = 20, verbose = TRUE)
)
lr.set
wine.lr
lr.wflow
parameters(lr.wflow)
wine.lr = logistic_reg(mode = "classification") %>%
set_engine("glm")
wine.lr = logistic_reg(mode = "classification") %>%
set_engine("glm") %>%
fit(classdigit ~ ., data = wine.train)
wine.lr.model = logistic_reg(mode = "classification") %>%
set_engine("glm") %>%
fit(classdigit ~ ., data = wine.train)
wine.lr.model %>%
predict(wine.test) %>%
bind_cols(wine.test) %>%
metrics(truth = classdigit, estimate = .pred_class)
wine.lr.model
summary(wine.lr.model)
wine.lr.model
plot(wine.lr.model)
wine.lr.model = logistic_reg(mode = "classification") %>%
set_engine("glm") %>%
fit(classdigit ~ ., data = wine.train)
wine.lr.model %>%
predict(wine.test) %>%
bind_cols(wine.test) %>%
metrics(truth = classdigit, estimate = .pred_class)
wine.dt = decision_tree(mode = "classification",
min_n = tune(),
cost_complexity = tune()) %>%
set_engine("rpart")
folds <- vfold_cv(wine.train, repeats = 2)
tree.wflow =
workflow() %>%
add_model(wine.dt) %>%
add_recipe(wine.recipe)
tree.set <- parameters(tree.wflow)
search_res =
tune_bayes(
tree.wflow,
resamples = folds,
param_info = tree.set,
initial = 5,
iter = 30,
metrics = metric_set(accuracy),
control = control_bayes(no_improve = 20, verbose = TRUE)
)
estimates = collect_metrics(search_res) %>% arrange(.iter)
show_best(search_res, metric = "accuracy")
autoplot(search_res, type = "performance")
optim.params <- show_best(search_res, metric = "accuracy")[1,]
final_rec <-
wine.recipe %>%
finalize_recipe(optim.params) %>%
prep()
model.tuned <-
wine.dt %>%
finalize_model(optim.params) %>%
fit(classdigit ~ ., data = wine.train)
model.tuned %>%
predict(wine.test) %>%
bind_cols(wine.test) %>%
metrics(truth = classdigit, estimate = .pred_class)
wine.lr.model = logistic_reg(mode = "classification") %>%
set_engine("glm") %>%
fit(classdigit ~ ., data = wine.train)
wine.lr.model %>%
predict(wine.test) %>%
bind_cols(wine.test) %>%
metrics(truth = classdigit, estimate = .pred_class)
wine.lr.model
wine.mlp = mlp(mode = "classification",
activation = "relu",
hidden_units = tune(),
dropout = tune(),
epochs = tune()) %>%
set_engine("rpart")
wine.mlp = mlp(mode = "classification",
activation = "relu",
hidden_units = tune(),
dropout = tune(),
epochs = tune()) %>%
set_engine("keras")
folds <- vfold_cv(wine.train, repeats = 2)
mlp.wflow =
workflow() %>%
add_model(wine.mlp) %>%
add_recipe(wine.recipe)
mlp.set <- parameters(mlp.wflow)
nlp.set
mlp.set
search_res =
tune_bayes(
mlp.wflow,
resamples = folds,
param_info = mlp.set,
initial = 5,
iter = 20,
metrics = metric_set(accuracy),
control = control_bayes(no_improve = 10, verbose = TRUE)
)
install.packages("keras")
search_res =
tune_bayes(
mlp.wflow,
resamples = folds,
param_info = mlp.set,
initial = 5,
iter = 20,
metrics = metric_set(accuracy),
control = control_bayes(no_improve = 10, verbose = TRUE)
)
wine.mlp = mlp(mode = "classification",
activation = "relu",
hidden_units = tune(),
dropout = tune(),
epochs = tune()) %>%
set_engine("nnet")
no
estimates = collect_metrics(search_res) %>% arrange(.iter)
show_best(search_res, metric = "accuracy")
wine.mlp = mlp(mode = "classification",
activation = "relu",
hidden_units = tune(),
dropout = tune(),
epochs = 10) %>%
set_engine("nnet")
folds <- vfold_cv(wine.train, repeats = 2)
mlp.wflow =
workflow() %>%
add_model(wine.mlp) %>%
add_recipe(wine.recipe)
mlp.set <- parameters(mlp.wflow)
search_res =
tune_bayes(
mlp.wflow,
resamples = folds,
param_info = mlp.set,
initial = 5,
iter = 20,
metrics = metric_set(accuracy),
control = control_bayes(no_improve = 10, verbose = TRUE)
)
wine.mlp = mlp(mode = "classification",
activation = "relu",
hidden_units = tune(),
dropout = tune(),
epochs = 10) %>%
set_engine("nnet")
folds <- vfold_cv(wine.train, repeats = 2)
mlp.wflow =
workflow() %>%
add_model(wine.mlp) %>%
add_recipe(wine.recipe)
mlp.set <- parameters(mlp.wflow)
mlp.set
wine.mlp = mlp(mode = "classification",
activation = "relu",
hidden_units = tune(),
dropout = 0.2,
epochs = 10) %>%
set_engine("nnet")
folds <- vfold_cv(wine.train, repeats = 2)
mlp.wflow =
workflow() %>%
add_model(wine.mlp) %>%
add_recipe(wine.recipe)
mlp.set <- parameters(mlp.wflow)
mlp.set
search_res =
tune_bayes(
mlp.wflow,
resamples = folds,
param_info = mlp.set,
initial = 5,
iter = 20,
metrics = metric_set(accuracy),
control = control_bayes(no_improve = 10, verbose = TRUE)
)
estimates = collect_metrics(search_res) %>% arrange(.iter)
show_best(search_res, metric = "accuracy")
wine.mlp = mlp(mode = "classification",
activation = "relu",
hidden_units = tune(),
dropout = 0.2,
epochs = 10) %>%
set_engine("nnet")
folds <- vfold_cv(wine.train, repeats = 2)
mlp.wflow =
workflow() %>%
add_model(wine.mlp) %>%
add_recipe(wine.recipe)
mlp.set <- parameters(mlp.wflow)
search_res =
tune_bayes(
mlp.wflow,
resamples = folds,
param_info = mlp.set,
initial = 5,
iter = 20,
metrics = metric_set(accuracy),
control = control_bayes(no_improve = 10, verbose = TRUE)
)
estimates = collect_metrics(search_res) %>% arrange(.iter)
show_best(search_res, metric = "accuracy")
autoplot(search_res, type = "performance")
optim.params <- show_best(search_res, metric = "accuracy")[1,]
final_rec <-
wine.recipe %>%
finalize_recipe(optim.params) %>%
prep()
model.tuned <-
wine.mlp %>%
finalize_model(optim.params) %>%
fit(classdigit ~ ., data = wine.train)
model.tuned %>%
predict(wine.test) %>%
bind_cols(wine.test) %>%
metrics(truth = classdigit, estimate = .pred_class)
wine.mlp = mlp(mode = "classification",
activation = "relu",
hidden_units = tune(),
dropout = 0.4,
epochs = 10) %>%
set_engine("nnet")
folds <- vfold_cv(wine.train, repeats = 2)
mlp.wflow =
workflow() %>%
add_model(wine.mlp) %>%
add_recipe(wine.recipe)
mlp.set <- parameters(mlp.wflow)
search_res =
tune_bayes(
mlp.wflow,
resamples = folds,
param_info = mlp.set,
initial = 5,
iter = 20,
metrics = metric_set(accuracy),
control = control_bayes(no_improve = 10, verbose = TRUE)
)
estimates = collect_metrics(search_res) %>% arrange(.iter)
show_best(search_res, metric = "accuracy")
autoplot(search_res, type = "performance")
optim.params <- show_best(search_res, metric = "accuracy")[1,]
final_rec <-
wine.recipe %>%
finalize_recipe(optim.params) %>%
prep()
model.tuned <-
wine.mlp %>%
finalize_model(optim.params) %>%
fit(classdigit ~ ., data = wine.train)
model.tuned %>%
predict(wine.test) %>%
bind_cols(wine.test) %>%
metrics(truth = classdigit, estimate = .pred_class)
wine.mlp = mlp(mode = "classification",
activation = "relu",
hidden_units = tune(),
dropout = 0.4,
epochs = 10) %>%
set_engine("keras")
folds <- vfold_cv(wine.train, repeats = 2)
mlp.wflow =
workflow() %>%
add_model(wine.mlp) %>%
add_recipe(wine.recipe)
mlp.set <- parameters(mlp.wflow)
search_res =
tune_bayes(
mlp.wflow,
resamples = folds,
param_info = mlp.set,
initial = 5,
iter = 20,
metrics = metric_set(accuracy),
control = control_bayes(no_improve = 10, verbose = TRUE)
)
estimates = collect_metrics(search_res) %>% arrange(.iter)
estimates
show_best(search_res, metric = "accuracy")
rlang::last_error()
rlang::last_trace()
search_res
search_res[4,]
search_res[4,:]
search_res[,4]
search_res[1,4]
optim.params <- show_best(search_res, metric = "accuracy")[1,]
final_rec <-
wine.recipe %>%
finalize_recipe(optim.params) %>%
prep()
model.tuned <-
wine.mlp %>%
finalize_model(optim.params) %>%
fit(classdigit ~ ., data = wine.train)
show_best(search_res, metric = "accuracy")
show_best(search_res)
model.tuned %>%
predict(wine.test) %>%
bind_cols(wine.test) %>%
metrics(truth = classdigit, estimate = .pred_class)
wine.lr.model = mlp(mode = "classification",
activation = "relu",
hidden_units = tune(),
dropout = 0.4,
epochs = 10) %>%
set_engine("keras") %>%
fit(classdigit ~ ., data = wine.train)
wine.lr.model = mlp(mode = "classification",
activation = "relu",
hidden_units = 5,
dropout = 0.4,
epochs = 10) %>%
set_engine("keras") %>%
fit(classdigit ~ ., data = wine.train)
wine.lr.model = mlp(mode = "classification",
activation = "relu",
hidden_units = 10,
dropout = 0.4,
epochs = 10) %>%
set_engine("keras") %>%
fit(classdigit ~ ., data = wine.train)
wine.lr.model = mlp(mode = "classification",
activation = "relu",
hidden_units = 3,
dropout = 0.4,
epochs = 10) %>%
set_engine("keras") %>%
fit(classdigit ~ ., data = wine.train)
wine.lr.model %>%
predict(wine.test) %>%
bind_cols(wine.test) %>%
metrics(truth = classdigit, estimate = .pred_class)
wine.lr.model = mlp(mode = "classification",
activation = "relu",
hidden_units = 4,
dropout = 0.4,
epochs = 10) %>%
set_engine("keras") %>%
fit(classdigit ~ ., data = wine.train)
wine.lr.model %>%
predict(wine.test) %>%
bind_cols(wine.test) %>%
metrics(truth = classdigit, estimate = .pred_class)
wine.lr.model = mlp(mode = "classification",
activation = "softmax",
hidden_units = 4,
dropout = 0.4,
epochs = 10) %>%
set_engine("keras") %>%
fit(classdigit ~ ., data = wine.train)
wine.lr.model %>%
predict(wine.test) %>%
bind_cols(wine.test) %>%
metrics(truth = classdigit, estimate = .pred_class)
wine.lr.model = mlp(mode = "classification",
activation = "relu",
hidden_units = 4,
dropout = 0.4,
epochs = 10) %>%
set_engine("keras") %>%
fit(classdigit ~ ., data = wine.train)
wine.lr.model %>%
predict(wine.test) %>%
bind_cols(wine.test) %>%
metrics(truth = classdigit, estimate = .pred_class)
optim.params <- show_best(search_res, metric = "accuracy")[1,]
wine.mlp = mlp(mode = "classification",
activation = "relu",
hidden_units = tune(),
dropout = 0.4,
epochs = 10) %>%
set_engine("nnet")
folds <- vfold_cv(wine.train, repeats = 2)
mlp.wflow =
workflow() %>%
add_model(wine.mlp) %>%
add_recipe(wine.recipe)
mlp.set <- parameters(mlp.wflow)
search_res =
tune_bayes(
mlp.wflow,
resamples = folds,
param_info = mlp.set,
initial = 5,
iter = 20,
metrics = metric_set(accuracy),
control = control_bayes(no_improve = 10, verbose = TRUE)
)
estimates = collect_metrics(search_res) %>% arrange(.iter)
show_best(search_res, metric = "accuracy")
estimates
final_rec <-
wine.recipe %>%
finalize_recipe(optim.params) %>%
prep()
model.tuned <-
wine.mlp %>%
finalize_model(optim.params) %>%
fit(classdigit ~ ., data = wine.train)
model.tuned %>%
predict(wine.test) %>%
bind_cols(wine.test) %>%
metrics(truth = classdigit, estimate = .pred_class)
wine.lr.model = mlp(mode = "classification",
activation = "relu",
hidden_units = 4,
dropout = 0.4,
epochs = 10) %>%
set_engine("keras") %>%
fit(classdigit ~ ., data = wine.train)
wine.lr.model %>%
predict(wine.test) %>%
bind_cols(wine.test) %>%
metrics(truth = classdigit, estimate = .pred_class)
wine.lr.model = mlp(mode = "classification",
activation = "relu",
hidden_units = 4,
dropout = 0,
epochs = 10) %>%
set_engine("keras") %>%
fit(classdigit ~ ., data = wine.train)
wine.lr.model %>%
predict(wine.test) %>%
bind_cols(wine.test) %>%
metrics(truth = classdigit, estimate = .pred_class)
estimates
wine.lr.model = mlp(mode = "classification",
activation = "relu",
hidden_units = 2,
dropout = 0,
epochs = 10) %>%
set_engine("keras") %>%
fit(classdigit ~ ., data = wine.train)
wine.lr.model %>%
predict(wine.test) %>%
bind_cols(wine.test) %>%
metrics(truth = classdigit, estimate = .pred_class)
